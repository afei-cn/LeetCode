# 502. IPO

假设 LeetCode 即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，LeetCode希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 LeetCode 设计完成最多 k 个不同项目后得到最大总资本的方式。

给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。

**示例 1:**

>**输入:** k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].
>
>**输出:** 4
>
>**解释:**
由于你的初始资本为 0，你尽可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
>

**注意:**
1. 假设所有输入数字都是非负整数。
2. 表示利润和资本的数组的长度不超过 50000。
3. 答案保证在 32 位有符号整数范围内。


# 解答

**题目分析:**

首先，由于每个项目都是获得纯利润，即不存在资本的损耗，所以我们总是去寻找当前资本下可以获得利润最高的项目即可，再将获取的利润加入到资本 W 中。

这是典型的 “贪婪算法”，我们每次都是寻找当前的最优解，并在投资 k 个不同项目后得到最优解。

**思路1:**

先说一个同样可以实现，但是效率不怎么高的实现吧（最终在输入数组长度为 50000 的 case 下运行超时了）。

1. 首先，将所有项目根据利润从大到小排序，使用快速排序，排序时间复杂度 O(n * lg n)。
2. 其次，我们从头开始遍历排序后的集合，找到第一个当前资本能够启动的项目，将其利润加入到资本 W 中，并将这个项目剔除。在这一步中，每一次我们都可以获得一个最优解。
3. 重复上一步，循环 k 次后得到最终最优解。

一切看起来合乎情理，然而提交代码出现了超时的情况。再回顾上述实现，发现查询过程其实效率很低，最糟糕的情况下总是需要遍历完整个集合才找到当前最优解（资金 W 能够启动的项目总是在最后一个）。这样循环 k 次时间复杂度就达到了 O(k * n) 了。

**思路2:**

既然上述情况的效率卡在了查询环节，我们就得想办法优化这一块了。仔细回顾原题，我们只有 W 的资本，大可不必在整个集合中依次查找，假设我们有一个这样的集合，它只包含我们能够启动的项目，那我们的搜索范围就小很多了，并在获得利润后再将当前 W 能够启动的项目加入到这个小集合中。

1. 我们选择使用一个优先队列 `profitQueue`，按照利润 Pi 从高到低，将我们当前 W 资本能够启动的项目添加进入
2. 我们在选择使用一个优先队列 `capitalQueue`，按照启动资本 Ci 从低到高，将剩余的项目添加进入
3. 我们在 `profitQueue` 取出利润最大者剔除，然后更新当前资本 W，资本 W 更新了就需要将当前资本 W 能够启动的项目从 `capitalQueue` 中移到 `profitQueue` 中
4. 重复上一步，执行 k 次后最终获得最优解

选择使用两个队列的好处是，我们不在需要完整的查询了，`profitQueue` 中一定都是我们可以启动的项目，且最大利润的项目总是在队首，取出来的时间复杂度为 O(1)，而插入新项目的时间复杂度也仅仅只有 O(lg n)。

**实现:**

[Solution.java](https://github.com/afei-cn/LeetCode/blob/master/502.%20IPO/src/Solution.java)