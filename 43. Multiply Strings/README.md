# 43. 字符串相乘

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1：**

> **输入：** num1 = "2", num2 = "3"
>
> **输出：** "6"

**示例 2：**

> **输入：** num1 = "123", num2 = "456"
>
> **输出：** "56088"

**说明：**

1. `num1` 和 `num2` 的长度小于110。
2. `num1` 和 `num2` 只包含数字 0-9。
3. `num1` 和 `num2` 均不以零开头，除非是数字 0 本身。
4. **不能使用任何标准库的大数类型（比如 BigInteger）** 或 **直接将输入转换为整数来处理**。

# 思路

### 1. 数字相乘的规律

假设，`num1` 的长度为 `m`，`num2` 的长度为 `n`，那么它们乘积的长度一定不超过 `m + n`。

比如 `9 * 9 = 81`，它绝不会到达三位数。

所以，我们可以创建一个字符数组 `value[]` 来保存结果，其长度为 `m + n` 。

### 2. 乘法计算

我们循环遍历两个字符串，将 `num1[i]` 与 `num2[j]` 相乘，并可以将结果存入到 `value[i + j + 1]` 中。

这里我们暂时先不考虑进位的问题，过程大致如下图所示（模拟 1234\*25 的过程）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181109082035652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FmZWlfXw==,size_16,color_FFFFFF,t_70)

### 3. 处理进位

我们从低位开始，一次将 `value[]` 数组中的每一位对 **10** 求余，并对 **10** 求商作为进位。

### 4. 处理最前端的 0

我们之前的数组长度设置的是 `m + n`，也许在最后结果并没有这么长，我们需要将前面的 0 全部清除掉。注意至少留一位数，针对于乘积结果刚好为 **0** 的情况。

# 实现
[Solution.java](https://github.com/afei-cn/LeetCode/blob/master/43.%20Multiply%20Strings/src/Solution.java)
