# 3. 无重复字符的最长子串

给定一个字符串，找出不含有重复字符的 **最长子串** 的长度。

**示例 1：**

> **输入：** "abcabcbb"
>
> **输出：** 3 
>
> **解释：** 无重复字符的最长子串是 "abc"，其长度为 3。

**示例 2：**

> **输入：** "bbbbb"
>
> **输出：** 1
>
> **解释：** 无重复字符的最长子串是 "b"，其长度为 1。

**示例 3：**

> **输入：** "pwwkew"
>
> **输出：** 3
>
> **解释：** 无重复字符的最长子串是 "wke"，其长度为 3。
>
> **请注意：** 答案必须是一个 **子串**，"pwke" 是一个子序列 而不是子串。

# 解答

暴力解答很简单但是其效率很低，我们会反复检查一个子字符串是否含有重复字符，但这没有必要。如果 [i, j-1] 之间的字符已经被检查为没有重复字符的话，那么我们只需判断 s[j] 是否存在于 [i, j-1] 中。判断的方式如果是一个个比较的话，效率也很低，我们可以将它们放置在一个 `HashSet` 中，通过 O(1) 时间完成判断。

**滑动窗口** 是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向 “滑动” 的窗口。例如，我们将 [i, j) 向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。

我们可以将 `HashSet` 升级为 `HashMap`，其中 key 依旧存放字符，value 则可以存放字符的索引加一。这样，当我们碰到重复字符时，可以将滑块的起点 `i`  设置为 `Math.max(map.get(s.charAt(j)), i)`。

**实现：**

[Solution.java](https://github.com/afei-cn/LeetCode/blob/master/3.%20Longest%20Substring%20Without%20Repeating%20Characters/src/Solution.java)
